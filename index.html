<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Motion Detector & Telegram Uploader</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #222;
            color: #eee;
            text-align: center;
        }
        #videoElement {
            max-width: 100%; /* Responsive video */
            border: 3px solid #4CAF50; /* Green border initially */
            display: block;  /* Remove extra space below inline element */
            margin: 0 auto; /* Center the video */
        }
        #canvasElement {
            display: none; /* Hidden canvas */
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
        }
        .motion-detected {
            border-color: red !important; /* Red border on motion */
        }
    </style>
</head>
<body>
    <h1>Pro Motion Detector</h1>
    <video id="videoElement" autoplay muted playsinline></video>
    <canvas id="canvasElement"></canvas>
    <div id="status">Starting...</div>

    <script>
        const TELEGRAM_BOT_TOKEN = '7785386019:AAHN8h2fje-njjcvAUUftx6TjJFE7rB4lvk';
        const CHAT_ID = '8101021767';
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvasElement');
        const context = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        let previousFrame = null;
        let motionDetectionActive = true; // Flag to control motion detection
        const motionThreshold = 20;  // Adjust sensitivity (lower = more sensitive)
        const captureDelay = 1000;   // Delay in milliseconds after motion detection
        let lastCaptureTime = 0; // Timestamp of the last capture
        const cooldownPeriod = 5000; // Minimum time between captures (5 seconds)

        // Error handling
        function handleError(message, error) {
            console.error(message, error);
            statusDiv.textContent = `Error: ${message}`;
            statusDiv.style.color = 'red';
        }


        // Get user media (camera)
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false }); // Prefer back camera, no audio
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    // Set canvas size to match video size.
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    statusDiv.textContent = "Camera ready. Detecting motion...";
                    detectMotion(); // Start motion detection after camera is ready
                };

            } catch (error) {
                handleError("Could not access the camera.", error)
            }
        }

        // Convert image data to grayscale
        function grayscale(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;     // Red
                data[i + 1] = avg; // Green
                data[i + 2] = avg; // Blue
            }
            return imageData;
        }


        // Detect motion between frames
        function detectMotion() {
            if (!motionDetectionActive) {
                requestAnimationFrame(detectMotion); // Keep looping even if paused
                return;
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const currentFrame = grayscale(context.getImageData(0, 0, canvas.width, canvas.height));

            if (previousFrame) {
                const diff = context.createImageData(canvas.width, canvas.height);
                let motionDetected = false;

                for (let i = 0; i < currentFrame.data.length; i += 4) {
                    const total = Math.abs(currentFrame.data[i] - previousFrame.data[i]); // Compare only red channel (grayscale)
                    if (total > motionThreshold) {
                        diff.data[i] = 255; // Red for motion
                        diff.data[i + 3] = 255; // Alpha
                        motionDetected = true;
                    } else {
                        diff.data[i + 3] = 0; // Transparent
                    }
                }

                if (motionDetected) {
                  video.classList.add('motion-detected');  // Add red border

                   const currentTime = Date.now();
                    if (currentTime - lastCaptureTime > cooldownPeriod) { // Check cooldown
                        statusDiv.textContent = "Motion detected! Capturing...";
                        captureAndSendImage();
                        lastCaptureTime = currentTime;
                    }
                } else {
                   video.classList.remove('motion-detected'); // Remove red border
                }
            }

            previousFrame = currentFrame; // Store current frame for next comparison
            requestAnimationFrame(detectMotion); // Continue the loop
        }


        // Capture image from canvas and send to Telegram
        async function captureAndSendImage() {
            canvas.toBlob(async (blob) => {
                if (!blob) {
                    handleError("Failed to create image blob.", null);
                    return;
                }

                const formData = new FormData();
                formData.append('chat_id', CHAT_ID);
                formData.append('photo', blob, 'motion_capture.png');

                try {
                    const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, {
                        method: 'POST',
                        body: formData,
                    });

                    const data = await response.json();
                    if (data.ok) {
                        statusDiv.textContent = `Image sent successfully at ${new Date().toLocaleTimeString()}`;
                        statusDiv.style.color = 'green';
                    } else {
                        handleError("Telegram API Error:", data);
                    }
                } catch (error) {
                    handleError("Failed to send image:", error);
                }
            }, 'image/png'); // Ensure PNG format
        }


        // Toggle motion detection (for demonstration purposes)
        function toggleMotionDetection() {
            motionDetectionActive = !motionDetectionActive;
            statusDiv.textContent = motionDetectionActive ? "Motion detection active" : "Motion detection paused";
        }

      // Start the camera and motion detection
      startCamera();

      // Add a button to toggle (optional, but good for testing)
      const toggleButton = document.createElement('button');
      toggleButton.textContent = 'Toggle Motion Detection';
      toggleButton.onclick = toggleMotionDetection;
      document.body.appendChild(toggleButton);

    </script>
</body>
</html>
