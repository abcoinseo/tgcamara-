<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Motion Detector (Hacker Style)</title>
    <style>
        body {
            font-family: monospace; /* Hacker-like font */
            background-color: #000; /* Black background */
            color: #0f0; /* Green text */
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Hide scrollbars */
        }
        #container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }
        #videoElement {
            width: 100%;
            display: block;
            border: 2px solid #0f0; /* Green border */
            box-shadow: 0 0 10px #0f0; /* Green glow */
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /*  display: none; */
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
        }
        /* "Hacker" style for motion detection */
        .motion-detected {
            border-color: red;
            box-shadow: 0 0 15px red;
            animation: flicker 0.5s infinite alternate; /* Flicker animation */
        }
        @keyframes flicker {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }

        /* Style for ROIs */
        .roi-box {
            position: absolute;
            border: 1px dashed #0f0;  /* Dashed green border */
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <h1>>_ Security Feed</h1> <!-- Hacker-like title -->
    <div id="container">
        <video id="videoElement" autoplay muted playsinline></video>
        <canvas id="overlayCanvas"></canvas>
    </div>
    <div id="status">Initializing...</div>

    <script>
        const TELEGRAM_BOT_TOKEN = '7785386019:AAHN8h2fje-njjcvAUUftx6TjJFE7rB4lvk'; // REPLACE
        const CHAT_ID = '8101021767'; // REPLACE
        const video = document.getElementById('videoElement');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        let previousFrame = null;
        const motionThreshold = 20;  // Lowered threshold for more sensitivity
        const cooldownPeriod = 1000; // 1 second cooldown
        let lastCaptureTime = 0;
        let isProcessing = false;


        // Define multiple Regions of Interest (ROIs) - normalized coordinates
        const rois = [
            { x1: 0.1, y1: 0.1, x2: 0.4, y2: 0.4, id: 'zone1' }, // Top-left
            { x1: 0.6, y1: 0.1, x2: 0.9, y2: 0.4, id: 'zone2' }, // Top-right
            { x1: 0.3, y1: 0.6, x2: 0.7, y2: 0.9, id: 'zone3' }  // Bottom-center
        ];

        function handleError(message, error) {
            console.error(message, error);
            statusDiv.textContent = `>_ ERROR: ${message}`; // Hacker-style error message
            statusDiv.style.color = 'red';
        }

       async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;

            video.onloadedmetadata = () => {
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;
                drawROIs(); // Draw ROIs on startup
                statusDiv.textContent = ">_ System Ready.  Monitoring...";
                requestAnimationFrame(processFrame);
            };
        } catch (err) {
            handleError("Camera access denied.", err);
        }
    }

    function grayscale(imageData) {
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = avg;
            data[i + 1] = avg;
            data[i + 2] = avg;
        }
        return imageData;
    }
    function drawROIs() {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); // Clear previous ROIs

            for (const roi of rois) {
                const x1 = roi.x1 * overlayCanvas.width;
                const y1 = roi.y1 * overlayCanvas.height;
                const x2 = roi.x2 * overlayCanvas.width;
                const y2 = roi.y2 * overlayCanvas.height;

                overlayCtx.strokeStyle = '#0f0'; // Green
                overlayCtx.lineWidth = 1;
                overlayCtx.setLineDash([5, 3]); // Dashed line
                overlayCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                overlayCtx.setLineDash([]);  // Reset dash

                 // Add ROI label
                overlayCtx.font = '10px monospace';
                overlayCtx.fillStyle = '#0f0';
                overlayCtx.fillText(roi.id, x1 + 5, y1 + 15);

            }
     }

    function detectMotionInROIs(currentFrame, previousFrame) {
          if (!previousFrame) {
            return false;
          }
        let motionDetected = false;


        for (const roi of rois) {
            const roiX1 = Math.floor(overlayCanvas.width * roi.x1);
            const roiY1 = Math.floor(overlayCanvas.height * roi.y1);
            const roiX2 = Math.floor(overlayCanvas.width * roi.x2);
            const roiY2 = Math.floor(overlayCanvas.height * roi.y2);

             let motionPixels = 0;
            const totalPixels = (roiX2 - roiX1) * (roiY2 - roiY1);


            for (let y = roiY1; y < roiY2; y++) {
                for (let x = roiX1; x < roiX2; x++) {
                    const index = (y * overlayCanvas.width + x) * 4;
                    const totalDifference = Math.abs(currentFrame.data[index] - previousFrame.data[index]);

                    if (totalDifference > motionThreshold) {
                      motionPixels++;
                      motionDetected = true
                    }
                }
            }

            const motionPercentage = (motionPixels / totalPixels) * 100;
            if(motionPercentage > 3) return true; //Consider it motion if > 3%

        }
        return motionDetected
    }

   async function processFrame() {
        if (isProcessing) {
            requestAnimationFrame(processFrame);
            return;
        }
        isProcessing = true;

        overlayCtx.drawImage(video, 0, 0, overlayCanvas.width, overlayCanvas.height);
        const currentFrame = grayscale(overlayCtx.getImageData(0, 0, overlayCanvas.width, overlayCanvas.height));

        if (detectMotionInROIs(currentFrame, previousFrame)) {
             video.classList.add('motion-detected');
            const currentTime = Date.now();
            if (currentTime - lastCaptureTime > cooldownPeriod) {
                statusDiv.textContent = ">_ Motion Detected! Intruder Alert!";
                captureAndSendImage();
                lastCaptureTime = currentTime;
            }
        } else {
            video.classList.remove('motion-detected');
            statusDiv.textContent = ">_ Monitoring...";
        }

        previousFrame = currentFrame;
        isProcessing = false;
        requestAnimationFrame(processFrame); // Request next frame
    }
    async function captureAndSendImage() {
        overlayCanvas.toBlob(async (blob) => {
            if (!blob) {
                handleError("Failed to create image blob.");
                return;
            }

            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('photo', blob, 'intruder_capture.jpg'); // "Hacker" filename

            try {
                const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();
                if (data.ok) {
                    statusDiv.textContent = ">_ Image transmitted.";
                    statusDiv.style.color = '#0f0';
                } else {
                    handleError("Telegram transmission failed.", data);
                }
            } catch (error) {
                handleError("Failed to send image.", error);
            }
        }, 'image/jpeg', 0.8);
    }

        startCamera();
    </script>
</body>
</html>
